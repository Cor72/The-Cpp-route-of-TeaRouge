
```c++
#include <iostream>   // cout/cin/endl
#include <algorithm>  // swap
using std::cout;
using std::cin;
using std::endl;

class Person 
{
public:
    Person()
    {
        cout << "默认构造函数调用";
    }
    Person(int age,int height)
    {
        m_Age=age;
        m_height = new int(height);
        cout << "有参构造函数调用";


    }


    //自己建立一个拷贝构造函数，以避免两个对象指向一个数据
    Person(const Person& p) {
        m_Age = p.m_Age;
        m_height = new int(*p.m_height);
    }


    ~Person()
    {
        //把在堆区的东西释放干净
        if (m_height != NULL) {
            delete m_height;
            m_height = NULL;
        }
        cout << "默认析构函数调用";
    }
    int m_Age;
    int* m_height;
};

void test01()
{

}

int main()
{
    Person p1(17, 92);
    cout << p1.m_Age << p1.m_height;
    Person p2(p1);
    cout << p2.m_Age << p1.m_height;

    
    cin.tie(0);
    cout.tie(0);
    return 0;
}
```



当然出现了问题

而且我打印的是**地址**，而非数字





看看kimi版本

下面把代码按“从上往下”的顺序一句一句拆开讲，并在讲解过程中指出所有潜在问题，最后给出一份可直接运行的修正版。

---

一、头文件与 using 声明

```cpp
#include <iostream>   // cout/cin/endl
#include <algorithm>  // swap
using std::cout;
using std::cin;
using std::endl;
```

- `#include <algorithm>` 其实没用到 `swap`，可以删。  
- 建议用 `using namespace std;` 或全部写 `std::`，混用容易看花眼。

---

二、Person 类

1. 默认构造  
   
```cpp
   Person() {
       cout << "默认构造函数调用";
   }
```

   - 没有初始化 `m_Age` 和 `m_height`，它们将是未定义值（UB）。  
   - 输出尾部没有 `\n` 或 `endl`，信息会黏在一起。

2. 有参构造  
   
```cpp
   Person(int age, int height) {
       m_Age = age;
       m_height = new int(height);
       cout << "有参构造函数调用";
   }
```

   - 同样缺少换行。  
   - 如果 `new` 失败会抛 `std::bad_alloc`，但这里没捕获。

3. 拷贝构造（深拷贝）  
   
```cpp
   Person(const Person& p) {
       m_Age = p.m_Age;
       m_height = new int(*p.m_height);
   }
```

   - 当 `p.m_height == nullptr` 时会解引用空指针（崩溃）。  
   - 建议加空指针保护：

     `m_height = p.m_height ? new int(*p.m_height) : nullptr;`

4. 析构函数  
   
```cpp
   ~Person() {
       if (m_height != NULL) {
           delete m_height;
           m_height = NULL;
       }
       cout << "默认析构函数调用";
   }
```

   - 打印信息叫“默认析构函数”其实不严谨，这是自定义析构。  
   - 用 `nullptr` 比 `NULL` 更现代。  
   - 再次缺少换行。

---

三、成员变量

```cpp
int m_Age;
int* m_height;
```

- 裸指针管理资源 → 三/五/零法则考虑不周，缺少  
  1. 拷贝赋值运算符  
  2. 移动构造/移动赋值

  否则会出现双重释放或浅拷贝。

---

四、test01 与 main

```cpp
void test01() { /* 空 */ }

int main() {
    Person p1(17, 92);
    cout << p1.m_Age << p1.m_height;   // 打印指针值无意义
    Person p2(p1);                     // 深拷贝 OK
    cout << p2.m_Age << p1.m_height;   // 又打印指针值
    cin.tie(0); cout.tie(0);           // 不解绑也行
    return 0;
}
```

- `cout << p1.m_height` 只会打印指针地址，不是身高值。  
- 缺少换行，输出挤在一行。  
- `cin.tie(nullptr); cout.tie(nullptr);` 才符合 C++11 后推荐写法。

---

五、完整、可直接编译运行的修正版

```cpp
#include <iostream>
using std::cout;
using std::endl;

class Person {
public:
    Person() : m_Age(0), m_height(nullptr) {
        cout << "默认构造函数\n";
    }

    Person(int age, int height) : m_Age(age), m_height(new int(height)) {
        cout << "有参构造函数\n";
    }

    // 拷贝构造（深拷贝）
    Person(const Person& other)
        : m_Age(other.m_Age),
          m_height(other.m_height ? new int(*other.m_height) : nullptr) {
        cout << "拷贝构造函数\n";
    }

    // 拷贝赋值运算符（遵循三/五法则）
    Person& operator=(const Person& other) {
        if (this != &other) {
            delete m_height;
            m_Age = other.m_Age;
            m_height = other.m_height ? new int(*other.m_height) : nullptr;
        }
        cout << "拷贝赋值运算符\n";
        return *this;
    }

    // 析构函数
    ~Person() {
        delete m_height;
        cout << "析构函数\n";
    }

    // 方便打印
    void print() const {
        cout << "Age: " << m_Age << ", Height: ";
        if (m_height) cout << *m_height;
        else          cout << "N/A";
        cout << '\n';
    }

private:
    int  m_Age;
    int* m_height;
};

int main() {
    Person p1(17, 180);
    p1.print();

    Person p2(p1);   // 拷贝构造
    p2.print();

    return 0;
}
```

- 用 `std::unique_ptr<int>` 可进一步避免裸指针，但先理解深/浅拷贝即可。  
- 编译：`g++ main.cpp -std=c++17 && ./a.out`